// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Varios');
gettext('apoyo');
gettext('Biestables');
gettext('Bombeo');
gettext('Neopixel');
gettext('Servos');
gettext('timers');
gettext('Kitt');
gettext('Reto 1: ¡Cárgame en la placa y pruébame! :-)');
gettext('Contador ascendente de 4bits, con entrada de cuenta');
gettext('Registro de 4 bits con entrada de load');
gettext('Agregador de 2 buses (2+2)  a bus de 4bits');
gettext('Separador de bus de 4bits en 2 (2 + 2)');
gettext('Registro de 2 bits, con entrada de load');
gettext('Separador de bus de 2bits');
gettext('Agregador de 2 cables a bus de 2bits');
gettext('Biestable D con enable inicializado a 0');
gettext('Biestable tipo D con entrada de enable, inicializado al parámetro INI');
gettext('Biestable D con inicialización paramétrica');
gettext('Multiplexor 2:1 de 1-bit');
gettext('Puerta OR');
gettext('Puerta NOT');
gettext('NAND logic gate');
gettext('Transistor');
gettext('Transistor cmos hecho a partir de semiconductores');
gettext('Cristal de Siicio');
gettext('Atomos de silicio');
gettext('Puerta AND');
gettext('Incrementar en 1 el dato de 4 bits');
gettext('Sumador de 4 bits con acarreo de salida');
gettext('Sumador de 4 bits con acarreo de salida y de entrada');
gettext('Sumador de 2 bits con acarreo de salida y de entrada');
gettext('Sumador de 1bit, con arraceo de entrada y salida');
gettext('Semisumador. 2 bits de entrada, saca la suma (S) y el acarreo (C)');
gettext('XOR logic gate');
gettext('Un bit constante a 0');
gettext('Valor constante 1 para bus de 4 bits');
gettext('Valor constante de 4 bits');
gettext('Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)');
gettext('Generar un pulso de reloj al recibir un flanco por la entrada');
gettext('Biestable D inicializado a 0');
gettext('Delay flip-flop');
gettext('Circuito combinacional de 4 entradas y 8 salidas');
gettext('Mux 2:1 with logic gates');
gettext('Entrada 1');
gettext('Entrada 0');
gettext('Selección');
gettext('Implementación en Verilog');
gettext('Las puertas están construidas a\npartir de transistores');
gettext('Pincha en algún transistor para\nbajar de nivel');
gettext('Nivel 3: Semiconductores');
gettext('Los transistores se crean a \npartir de uniones entre \nsemiconductores, de tipo P y N\nEstán integrados en los dados de\nsilicio en los circuitos integrados');
gettext('Pincha en el bloque para bajar de nivel');
gettext('Nivel 2: MATERIALES');
gettext('Cristal de silicio');
gettext('Los semiconductores se crean a partir de cristales\nde Silicio (Si) que se dopans con impurezas\npara darle las propiedades de semiconductores');
gettext('Pincha en los bloques para bajar de nivel');
gettext('Átomos de Silicio');
gettext('Nivel 1: ATOMOS');
gettext('Los cristales de silicio se forman a \npartir del enlace covalente entre los\nátomos de silicio. Cada uno de ellos \nestá rodeado por 4 átomos de silicio\nformando un tetraedro');
gettext('RAM-doble');
gettext('Memoria de datos');
gettext('RAM256-doble');
gettext('Memoria de datos de 256 palabras');
gettext('RAM512-doble');
gettext('Memoria de datos de 512 palabras');
gettext('tics');
gettext('Heart-1Hz');
gettext('Corazón de bombeo de tics a la frecuencia de 1Hz');
gettext('Heart-1Sec-ena');
gettext('Corazón de bombeo de tics con periodo de 1 de segundo, con enable');
gettext('Corazón de bombeo de tics a con periodo paramétrico de segundos');
gettext('Heart-Hz');
gettext('Corazón de bombeo de tics a un frecuencia parametrica en Hz');
gettext('Heart-Sec-ena');
gettext('Heart-Sec');
gettext('Heart-ms');
gettext('Corazón de bombeo de tics a con periodo paramétrico de milisegundos');
gettext('Heart-us');
gettext('Corazón de bombeo de tics a con periodo paramétrico de microsegundos');
gettext('NeoPixel-16');
gettext('Controlador de hasta 16 LEDs Neopixels');
gettext('Codificador de bits para los Neopixels');
gettext('Temporizador en tics. La señal p está activa durante los tics indicados. ov se emite un tic al finalizar');
gettext('Multiplexor de 2 a 1');
gettext('Temporizacion para las tramas neopixel');
gettext('Corazón  finito de tics. Emitir num tics cuando se recibe un tic de start');
gettext('Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en tics también');
gettext('Contador módulo M, ascendente, de 5 bits, con reset ');
gettext('Contador módulo M, ascendente, de 4 bits, con reset ');
gettext('Registro de desplazamiento para envio serie a los neopixels. El valor se introduce en formato RGB');
gettext('Temporizador de tiempo de 1 bit de la trama del neopixel');
gettext('Temporizador en microsegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('Emitir un tic inicial al arrancar, y nunca más');
gettext('## Fase 2. Test 31:  Acceso mediante memoria......  \nFunciona que te cagas!!!! :-)  \nPor un puerto se escribe en la memoria, que se está refrescando constantemente  \n\nTodas las partes documentadas. Es el esquem base para a patir de él sacar el bloque\n');
gettext('**Init-tic**');
gettext('Tic generado al comienzo,  \npara arrancar el controlador');
gettext('Espera superior a 50 us  \nIndica el comienzo  \nde la trama\ntrama nueva');
gettext('Evento: Comienza  \nla trama');
gettext('Evento: Trama anterior  \nenviada');
gettext('Evento: Empieza ciclo nuevo  \nBien porque es el primero  \no bien porque ha acabado el anterior');
gettext('Estado: Refrescando los LEDs  \n0: Dejar de refrescar  \n1: Refrescando');
gettext('Trama completa enviada  \nParar refresco');
gettext('Trama nueva:  \ncomenzar refresco');
gettext('Arrancar trama de datos  \npara el LED actual  \nGenera 24 tics, uno  \npara cada BIT');
gettext('**NeoHeart**');
gettext('Evento: LED actual procesado. Pasar al siguiente (si hay más)');
gettext('**NeoBit**');
gettext('Esperar un tiempo igual  \na un bit del Neopixel');
gettext('Evento: estamos refrescando  \ny ha terminado la trama  \nanterior');
gettext('Se ha comenzado  \na enviar el  \núltimo bit');
gettext('Número máximo de  \nLEDs en la tira');
gettext('Contador de LEDs  \nIndica el LED que  \nse está refrescando');
gettext('Evento: Incrementar  \nnumero de LED');
gettext('Evento: se han refrescado  \ntodos los LEDs');
gettext('Evento: Cargar datos para  \nactualizar el LED');
gettext('Evento: Desplazar un bit');
gettext('Evento: Bit nuevo');
gettext('La señal de shift está  \nretrasada con respecto a  \nload. Primero se carga,\nluego se desplaza');
gettext('Último bit ya enviado');
gettext('**NeoReg**');
gettext('Registro de desplazamiento de 24 bits  \npara cargase con el valor del LED actual  \ny enviar sus bits en serie');
gettext('**NeoCode**');
gettext('Codificar los bits. Cada uno  \nuna anchura');
gettext('Bit a enviar  \nal LED');
gettext('Acceder al valor  \ndel LED actual');
gettext('**Memoria de LEDS**  \nContiene los valores iniciales  \nde los LEDs');
gettext('Valor RGB a enviar al  \nLED actual');
gettext('**Funcionamiento**. El controlador está constantemente leyendo  \nla memoria y enviando sus valores a los LEDs.\n\nCada LED ocupa una posició de memoria, de 24 bits de anchura\n\nEn cualquier momento se puede escribir desde el exterior un valor  \nRGB en el LED indicado por su dirección (0 - 15). El controlador lo  \nenviará a los LEDs (refresco)');
gettext('Pulso de 833ns\nde anchura');
gettext('Pulso de 417\nde anchura');
gettext('## Codificación de bits en los Neopixels\n\nLos bits tienen el mismo periodo (1.25us) pero cada uno tiene una anchura de pulso diferente\n\n|Bit  | Anchura nominal  |  tics  | Anchura real | Error | Descripción |\n|-----|------------------|--------|--------------|-------|-------------|\n|Bit 0|  400ns           |   5    |   417ns      | 17ns  | Tolerancia: +-150ns |\n|Bit 1|  800ns           |   10   |   833ns      | 33ns  | Tolerancia: +-150ns |\n\nEl error es de 17ns y 33ns, que está dentro de lo permitido (tiene que ser menor de 150ns)');
gettext('**Bit a codificador: 0, 1**');
gettext('**Enviar bit**  \n(entrada tic)');
gettext('**Salida del bit**  \nCodificado');
gettext('Conectar directamente al pin  \ndonde estén los neopixels');
gettext('**Salida de pulso**');
gettext('**Salida de tic**');
gettext('**Arranque del**  \n**temporizador**');
gettext('## NEOHeart: Temporización para el envío de una trama neopixel para un LED\n\nEl periodo de los bits es de 1.25us (15 tics de 12Mhz)  \nLa trama está formada por 24 bits (8 bits por cada color RGB)');
gettext('**Enviar los tics**  \n**de cada bit de la trama**');
gettext('**Último tic**  \n**enviado**');
gettext('**Parámetro**: Módulo del contador');
gettext('**Parametro del timer**  \nmicroseundos a esperar');
gettext('NeoPixel-256');
gettext('Controlador de hasta 256 LEDs Neopixels');
gettext('Contador módulo M, ascendente, de 8 bits, con reset ');
gettext('## Neopixel-256\n');
gettext('NeoPixel-512');
gettext('Controlador de hasta 512 LEDs Neopixels');
gettext('Contador módulo M, ascendente, de 9 bits, con reset ');
gettext('## Neopixel-512\n');
gettext('heart-tic-finito');
gettext('neobit');
gettext('neocodec');
gettext('neoheart');
gettext('neoreg');
gettext('ServoTime-20ms');
gettext('Controlador PWM para posicionar servos de 20ms. Las unidades de pos son de 10usec');
gettext('<B>Posicion del servo</B>\n\nSe especifica en unidades de 10micro-segundos\nEj. pos = 100 --> Pulso de achura 1ms');
gettext('<B>Generación de una señal PWM para posicionamiento de Servos</B>\nEl periodo es de 20ms\nEl ancho del pulso varía entre 0 - 255 (0 - 2.5ms)');
gettext('timer-msec');
gettext('Temporizador en milisegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('**Parametro del timer**  \nmilisegundos a esperar');
gettext('timer-sec');
gettext('Temporizador en segundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('**Parametro del timer**  \nSegundos a esperar');
gettext('logica-reset');
gettext('Logica combinacional para reset y enable');
gettext('Biestables');
gettext('arcade');
gettext('cod');
gettext('decod');
gettext('demux');
gettext('pulsador-tic');
gettext('Heart-test-1');
gettext('Agregador de 2 cables a bus de 4bits');
gettext('Neopixel-test-1');
gettext('Multiplexor de 2 a 1 de 24 bits');
gettext('Biestable de cambio (Tipo T). Cuando se recibe un tic cambia de estado');
gettext('Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador');
gettext('Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('Agregador de buses de 2-bits a bus de 4-bits');
gettext('**Pulsador-tic**');
gettext('Neopixel-test-2');
gettext('**NeoPixel-16**');
gettext('Contador para direccionar los 12  \nLED del anillo');
gettext('Número de LED  \n(Dirección)');
gettext('Temporización: Generación de  \ntics de 50 mili-segundos');
gettext('Escribir el valor en el  \nLED actual');
gettext('Valor rgb para  \nel LED');
gettext('Registro de desplazamiento para obtener  \nel siguiente valor rgb\n');
gettext('Evento: se han recorrido  \nlos 12 LEDs');
gettext('Neopixel-test-3');
gettext('Detección de objeto con sensor de infrarrojos (IR). Emite un tic cada vez detecta un objeto');
gettext('**IRr-tic**');
gettext('Neopixel-test-4');
gettext('Multiplexor de 2 a 1 de 4 bits');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Comparador de igualdad para números de 4 bit');
gettext('Comparador de igualdad para números de 2 bit');
gettext('Comparador de igualdad para números de 1 bit');
gettext('Neopixel256-test-1');
gettext('**NeoPixel-256**');
gettext('Neopixel512-test-1');
gettext('**NeoPixel-512**');
gettext('ServoTime-Futaba3003');
gettext('Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 180 grados');
gettext('Valor constante para bus de 8 bits');
gettext('Mux 2:1. Bus de 7 bits. ');
gettext('Mux 2:1. Bus de 4 bits. ');
gettext('Agregador de 4 cables a bus de 4bits');
gettext('Separador de bus de 4bits en 4 cables (1 + 1 + 1 + 1)');
gettext('Separador de bus de 8bits en 2 (4 + 4)');
gettext('Agregador de 2 buses de 4 a bus de 8bits');
gettext('Divisor de frecuencia entre 2');
gettext('Bombear 1 bit por segundo');
gettext('Ejemplo de utilización del ServoTime para mover un o\nServo del tipo <B>Futaba 3003</B> o compatible\n\nEl extremo derecho son 0.4ms y el izquierdo 2.1ms\nEl ángulo de rotación es de 180 grados');
gettext('Extremo izquierdo');
gettext('Extremo derecho');
gettext('Mostrar posicion\nen los LEDs');
gettext('Señal de periodo 4 segundos. Dos seg.\nen extremo derecho y otros dos en el \nizquierdo');
gettext('gravedad');
gettext('pre-mips-0');
gettext('Circuito combinacional de 2 entradas y 32 salidas');
gettext('Contador módulo M, ascendente, de 2 bits, con reset ');
gettext('Multiplexor de 2 a 1 de 8 bits');
gettext('Valor constante 0 para bus de 8 bits');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('test-botones');
gettext('DisplayBit3. Decodificador de 3 bits a 7 segmentos. Cátodo común');
gettext('Codificador de 2 a 1. La salida zero se activa cuando ninguna entrada está activada');
gettext('Multiplexor de 2 a 1 de 3 bits');
gettext('Agregador de 3 cables en un bus de 3-bits');
gettext('Separador de bus de 3-bits');
gettext('Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente');
gettext('**Display 7 seg**');
gettext('timer-msec-test1');
gettext('timer-msec-test2');
gettext('timer-msec-test3');
gettext('Generacion de pulsos de 1 periodo con un pulsador');
gettext('Remove the rebound on a mechanical switch');
gettext('timer-msec-test4');
gettext('timer-sec-test');
gettext('timer-test');
gettext('Contador ascendente de 8bits, con reset síncrono y entrada de cuenta');
gettext('Sumar 1 al bus de 8 bits');
gettext('Registro de 8 bits, con reset síncrono y entrada de load');
gettext('Agregador de 2 cables a bus de 8bits');
gettext('Registro de 4 bits con reset síncrono y entrada de load');
gettext('Registro de 2 bits, con load y reset síncrono');
gettext('Biestable D, con reset síncrono y enable, inicializado a 0');
gettext('Biestable tipo D con entrada de reset y enable, inicializado al parámetro INI');
gettext('NOT logic gate');
gettext('AND logic gate');
gettext('OR logic gate');
gettext('Constante genérica de 1 bit');
gettext('Comparador de 8 bits');
gettext('timer-test2');
gettext('timer-test3');
gettext('Estado del temporizador  \n0: Apagado  \n1: Funcionando');
gettext('Unidades a contar:  \nsegundos');
gettext('Contador de  \nsegundos');
gettext('Evento: cuenta máxima de tics alcanzada');
gettext('Lógica de reset. En función  \nde la entrada, el estado y  \nel overflow se inicializa  \nel contador y se habilita  \nel corazón de tics');
gettext('timer-test4');
gettext('timer-test5');
gettext('timer-test6');
gettext('timer-test7');
gettext('timer-test8');
gettext('Salida opcional  \npara depurar');
gettext('timer-test9');
gettext('Test-Cambio-1');
gettext('Test-dato-1');
gettext('Disparos-arcade-2');
gettext('Un bit constante a 1');
gettext('Corazón de bombeo de tics con periodo paramétrico de segundos y entrada de enable');
gettext('## Ejemplo x: Disparos arcade\n\n');
gettext('Disparos-arcade-3');
gettext('Disparos-arcade-4');
gettext('Disparos-arcade');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en micro-segundos. Solo se hace el bombeo cuando está habilitado');
gettext('Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente');
gettext('Dato del tercer biestable');
gettext('Test-cod-2-1');
gettext('Test-cod-4-1');
gettext('Codificador de 4 a 1, con prioridad. La salida zero se activa cuando ninguna entrada está activad');
gettext('cod-2-1');
gettext('Test-decod-1-2');
gettext('Decodificador de 1 a 2');
gettext('Test-decod-2-4');
gettext('Decodificador de 2 a 4');
gettext('Test-decod-3-8');
gettext('Decodificador de 3 a 8');
gettext('Test-demux-1-2');
gettext('Demultiplexor de 1 bit, de 1 a 2');
gettext('Test-demux-2-4');
gettext('Demultiplexor de 1 bit, de 2 a 4');
gettext('pulsador-1');
gettext('Contador ascendente de 3 bits con reset síncrono y entrada de cuenta');
gettext('Sumar 1 al bus de 3 bits');
gettext('Registro de 3 bits, con reset síncrono y entrada de carga');
gettext('Separador de bus de 3bits en 2 (2 + 1)');
gettext('Agregador de 2 cables a bus de 3bits');
gettext('pulsador-2');
gettext('**ZIPCPU**: https://zipcpu.com/blog/2017/08/04/debouncing.html\n\n');
gettext('**SYNC**');
gettext('pulsador-3');
gettext('**Antirrebotes**');
gettext('pulsador-4');
gettext('pulsador-5');
gettext('pulsador-6');
gettext('pulsador-7');
