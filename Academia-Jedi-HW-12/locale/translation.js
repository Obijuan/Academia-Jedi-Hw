// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Bits');
gettext('Puertas');
gettext('Varios');
gettext('0');
gettext('Un bit constante a 0');
gettext('1');
gettext('Un bit constante a 1');
gettext('and');
gettext('Puerta AND');
gettext('not');
gettext('Puerta NOT');
gettext('Bombeo');
gettext('Retardo');
gettext('Servos');
gettext('Corazon_10Hz');
gettext('Bombear 1 bit por segundo');
gettext('Corazon_1Hz');
gettext('Corazon_2Hz');
gettext('Corazon_3Hz');
gettext('Corazon_4Hz');
gettext('Corazon_5Hz');
gettext('Corazon_7Hz');
gettext('Tortuga-2');
gettext('Divisor entre dos');
gettext('Biestable T síncrono, inicializado a 0');
gettext('Biestable T síncrono, inicializado por parametro INI');
gettext('Biestable tipo D con entrada de enable, inicializado al parámetro INI');
gettext('Biestable D con inicialización paramétrica');
gettext('Multiplexor 2:1 de 1-bit');
gettext('Puerta OR');
gettext('NAND logic gate');
gettext('Transistor');
gettext('Transistor cmos hecho a partir de semiconductores');
gettext('Cristal de Siicio');
gettext('Atomos de silicio');
gettext('Generar un pulso de reloj al recibir un flanco por la entrada');
gettext('Biestable D inicializado a 0');
gettext('Delay flip-flop');
gettext('Tortuga: Divisor entre 2\n\nImplementado a partir de un\nbiestable T síncrono');
gettext('Hacer que solo responda a los flancos\nde subida de la señal de entrada');
gettext('Mux 2:1 with logic gates');
gettext('Entrada 1');
gettext('Entrada 0');
gettext('Selección');
gettext('Implementación en Verilog');
gettext('Las puertas están construidas a\npartir de transistores');
gettext('Pincha en algún transistor para\nbajar de nivel');
gettext('Nivel 3: Semiconductores');
gettext('Los transistores se crean a \npartir de uniones entre \nsemiconductores, de tipo P y N\nEstán integrados en los dados de\nsilicio en los circuitos integrados');
gettext('Pincha en el bloque para bajar de nivel');
gettext('Nivel 2: MATERIALES');
gettext('Cristal de silicio');
gettext('Los semiconductores se crean a partir de cristales\nde Silicio (Si) que se dopans con impurezas\npara darle las propiedades de semiconductores');
gettext('Pincha en los bloques para bajar de nivel');
gettext('Átomos de Silicio');
gettext('Nivel 1: ATOMOS');
gettext('Los cristales de silicio se forman a \npartir del enlace covalente entre los\nátomos de silicio. Cada uno de ellos \nestá rodeado por 4 átomos de silicio\nformando un tetraedro');
gettext('Emax-ES08A');
gettext('Futaba-3003');
gettext('TowerPro-SG90');
gettext('ServoBit-90');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('Valor constante para bus de 8 bits');
gettext('Mux 2:1. Bus de 7 bits. ');
gettext('Mux 2:1. Bus de 4 bits. ');
gettext('Agregador de 4 cables a bus de 4bits');
gettext('Separador de bus de 4bits en 4 cables (1 + 1 + 1 + 1)');
gettext('Separador de bus de 8bits en 2 (4 + 4)');
gettext('Agregador de 2 buses de 4 a bus de 8bits');
gettext('Controlador PWM para posicionar servos de 20ms. Las unidades de pos son de 10usec');
gettext('Posición 0');
gettext('Posición 1');
gettext('<B>Posicion del servo</B>\n\nSe especifica en unidades de 10micro-segundos\nEj. pos = 100 --> Pulso de achura 1ms');
gettext('<B>Generación de una señal PWM para posicionamiento de Servos</B>\nEl periodo es de 20ms\nEl ancho del pulso varía entre 0 - 255 (0 - 2.5ms)');
gettext('Servobit-90');
gettext('ServoBit para Futaba 3003. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('Servobit-90');
gettext('ServoBit para micrservo TowerPro-SG90. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('<B>Servobit</B> para microservos TowerPro SG-90 o compatibles\nLas dos posiciones están distanciadas 90 grados\n\n* Posicion 0: 45 grados\n* Posicion 1: 135 grados');
gettext('0-Soluciones-Tutorial-11');
gettext('1-Ejemplos');
gettext('2-Ejercicios');
gettext('Sol-11-1');
gettext('Sol-11-2');
gettext('Sol-11-3');
gettext('01-Pulsador-interruptor-LEDs');
gettext('<B>Ejemplo 1</B>: Un pulsador y un interruptor externos conectados\na los LEDs 7 y 0 respectivamente');
gettext('02-tres-Interruptores-LEDs');
gettext('<B>Ejemplo 2</B>: Mostrar el estado de 3 interruptores\nen los LEDs');
gettext('03-cerradura-clave');
gettext('<B>Ejemplo 3</B>: Apertura de cerradura con código\n\nEl código se introduce por los interruptres. El que abre la cerradura\nes el 111 (los tres interruptores a 1)');
gettext('Por los LEDs se saca\nel estado de los\ntres interruptores');
gettext('Esta señal se activa si\nel codigo es correcto\nEl int. 1 está activado Y\nel int. 2 está activado Y\nel int. 3 está activado');
gettext('Si el código es correcto\nY se aprieta el pulsador,\nSe activa el servo para abrir\nla cerradura');
gettext('Ejercicio-12-1');
gettext('<B>Ejercicio 12.1</B>: (5 Bitpoints) Utilizar un interruptor y pulsador externos para \ncontrolar a Franky. Diseñar un circuito digital para que Franky mueva la cabeza a \nderecha o izquierda según el estado del interruptor. Al apretar el pulsador ambos ojos \nparpadearán con una frecuencia de 10Hz\n\nCon esto convertimos a Franky en un robot defensivo. Con sus ráfagas láser dispara a \nlos enemigos, que le vienen por la derecha y la izquierda');
gettext('Entregar:\n\n  -1 Pantallazo del circuito (2 Bitpoints)\n  -1 Vídeo del funcionamiento (2 Bitpoints)\n  \n  Enviarlos por redes sociales (Twitter, G+) con mención \n  a @Obijuan_cube. El vídeo puede estar en youtube o directamente en el tuit/post');
gettext('GITHUB:\n\n  1 Bitpoint adicional si lo entregáis por Github (sólo pantallazo, el vídeo\n  no hace falta, para que no ocupe tanto espacio)');
gettext('Ejercicio-12-2');
gettext('<B>Ejercicio 12.2</B>: (3 Bitpoints) Hacer un circuito digital con un pulsador \nexterno para abrir y cerrar la barrera. Al apretarlo se abre, y al soltarlo se cierra. \nAñadir un interruptor externo para habilitar / deshabilitar el control manual de la \nbarrera. Sólo funcionará el pulsador cuando el interruptor está a 1. Cuando esté a 0\nla barrera estará bloqueda, y aunque se apriete el pulsador NO se abrirá\n');
gettext('Entregar:\n\n  -1 Pantallazo del circuito (1 Bitpoints)\n  -1 Vídeo del funcionamiento (1 Bitpoints)\n  \n  Enviarlos por redes sociales (Twitter, G+) con mención \n  a @Obijuan_cube. El vídeo puede estar en youtube o directamente en el tuit/post');
gettext('Ejercicio-12-3');
gettext('<B>Ejercicio 12.3</B>: (5 Bitpoints) Hacer un circuito digital para controlar la apertura\nde una caja fuerte. Hay tres pulsadores externos para introducir la clave. Hay un pulsador\nexterno para abrir la caja. Sólo se abrirá si la clave introducida en los interruptores\nes la correcta. Esta clave será 101 (Interruptores primero y tercero a 1, y el segundo a cero)\nCuando la clave es la correcta y se aprieta el pulsador, se moverá un servo que simula el cierre\nde la caja. Al soltar el pulsador el servo volverá a su posición inicial\n');
gettext('<B>NOTA</B>: El funcionamiento de esta caja fuerte es todavía muy básico. En sucesivos tutoriales\nlo iremos refinando. Como todavía no sabemos usar elementos de memoria, el servo vuelve a\nsu posición inicial al dejar de apretar el pulsador');
