// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Comb');
gettext('Const');
gettext('Varios');
gettext('Mux');
gettext('Puertas');
gettext('Tablas');
gettext('1-Bit');
gettext('2-Bits');
gettext('4-Bits');
gettext('8-Bit');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1');
gettext('Mux-2-1');
gettext('Mux-4-1-flip');
gettext('Multiplexor de 4 a 1. Implementado en verilog');
gettext('Mux-4-1');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 2 bits');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 2 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 4 bits');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 4 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 8 bits');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 8 bits');
gettext('and');
gettext('Puerta AND');
gettext('nand');
gettext('Puerta NAND');
gettext('nor');
gettext('Puerta NOR');
gettext('not');
gettext('Puerta NOT');
gettext('or');
gettext('Puerta OR');
gettext('xnor');
gettext('Puerta XNOR');
gettext('xor');
gettext('Puerta XOR');
gettext('tabla-1-1');
gettext('Circuito combinacional de 1 entrada y 1 salida');
gettext('tabla-2-1');
gettext('Circuito combinacional de 2 entradas y 1 salida');
gettext('tabla-2-2');
gettext('Circuito combinacional de 2 entradas y 2 salida');
gettext('tabla-3-1');
gettext('Circuito combinacional de 3 entradas y 1 salida');
gettext('tabla-4-1');
gettext('Circuito combinacional de 4 entradas y 1 salida');
gettext('Bits');
gettext('Bus');
gettext('0');
gettext('Un bit constante a 0');
gettext('1');
gettext('Un bit constante a 1');
gettext('02_bits');
gettext('04_bits');
gettext('08_bits');
gettext('Generico');
gettext('Valor genérico constante, de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_0');
gettext('Valor constante 0 para bus de 2 bits');
gettext('Valor_1');
gettext('Valor constante 1 para bus de 2 bits');
gettext('Valor_2');
gettext('Valor constante 2 para bus de 2 bits');
gettext('Valor_3');
gettext('Valor constante 3 para bus de 2 bits');
gettext('Generico');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_00');
gettext('Valor constante 0 para bus de 4 bits');
gettext('Valor_05');
gettext('Valor constante 5 para bus de 4 bits');
gettext('Valor_10');
gettext('Valor constante 10 para bus de 4 bits');
gettext('Valor_15');
gettext('Valor constante 15 para bus de 4 bits');
gettext('Generico');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_000');
gettext('Valor constante 0 para bus de 8 bits');
gettext('Valor_085');
gettext('Valor constante 85 (55h) para bus de 8 bits');
gettext('Valor_170');
gettext('Valor constante 170 (AAh) para bus de 8 bits');
gettext('Valor_255');
gettext('Valor constante 255 para bus de 8 bits');
gettext('Bombeo');
gettext('Bus');
gettext('Motor');
gettext('Retardo');
gettext('Servos');
gettext('Fijos');
gettext('Corazon_Hz');
gettext('Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)');
gettext('Corazon_Seg');
gettext('Bombear 1 bit con el periodo especificado en el parámetro. Por defecto el periodo es de 1 segundos');
gettext('Corazon_10Hz');
gettext('Bombear 10 bits por segundo');
gettext('Creado a partir de un **corazón  \ngenérico**, dando el valor adecuado  \na su parámetro frecuencia');
gettext('Corazon_1Hz');
gettext('Bombear 1 bit por segundo');
gettext('Corazon_1KHz');
gettext('Bombear 1000 bits por segundo');
gettext('Corazon_2Hz');
gettext('Bombear 2 bits por segundo');
gettext('Corazon_2KHz');
gettext('Bombear 2000 bits por segundo');
gettext('Corazon_3Hz');
gettext('Bombear 3 bits por segundo');
gettext('Corazon_4Hz');
gettext('Bombear 4 bits por segundo');
gettext('Corazon_5Hz');
gettext('Bombear 5 bits por segundo');
gettext('Corazon_7Hz');
gettext('Bombear 7 bits por segundo');
gettext('Corazon_DO4');
gettext('Bombear bits a la frecuencia del DO de la cuarta octava');
gettext('Corazon_MI4');
gettext('Bombear bits a la frecuencia del MI de la cuarta octava');
gettext('Corazon_RE4');
gettext('Bombear bits a la frecuencia del RE de la cuarta octava');
gettext('02_bits');
gettext('04_bits');
gettext('08_bits');
gettext('Agregador');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('Separador');
gettext('Separador de bus de 2-bits en dos cables');
gettext('Agregador');
gettext('Agregador de buses de 2-bits a bus de 4-bits');
gettext('Separador');
gettext('Separador de bus de 4-bits en buses de 2 bits');
gettext('Agregador');
gettext('Agregador de 2 buses de 4-bits a bus de 8-bits');
gettext('Separador');
gettext('Separador de bus de 8-bits en buses de 4 bits');
gettext('SM-S4303R');
gettext('MotorBit');
gettext('Controlador para servo de rotacion continua SprintRC SM-S4303R. Con on=1, el motor avanza. Dir=1 sentido agujas reloj/ 0 el contrario. V1 y V2 son los pulsos para las velocidades horaria y antihoraria (en micro-sec). V0 para que esté parado');
gettext('Mux 2:1. Bus de 7 bits. ');
gettext('Mux 2:1. Bus de 4 bits. ');
gettext('Agregador de 4 cables a bus de 4bits');
gettext('Separador de bus de 4bits en 4 cables (1 + 1 + 1 + 1)');
gettext('Multiplexor 2:1 de 1-bit');
gettext('NAND logic gate');
gettext('Transistor');
gettext('Transistor cmos hecho a partir de semiconductores');
gettext('Cristal de Siicio');
gettext('Atomos de silicio');
gettext('Separador de bus de 8bits en 2 (4 + 4)');
gettext('Agregador de 2 buses de 4 a bus de 8bits');
gettext('Controlador PWM para posicionar servos de 20ms. Las unidades de pos son de 10usec');
gettext('**Velocidad 1**: Velocidad para el  \nsentido de giro horario\n');
gettext('**Velocidad 2**: Velocidad para el \nsentido de giro antirhorario');
gettext('**Entrada on/off**: Motor en  \nmovimiento o parado');
gettext('**Motorbit paramétrico** para los **SM-S4303R** o compatibles\n\nTiene 3 parámetros, especificados en micro-segundos. **V1** y **V2** son las posiciones (ancho del pulso)  \npara las velocidades de giro en sentido horario y antihorario respectivamente\n\n**V0** es la posición en la que el servo está parado (velocidad 0)\n\nPor defecto se asignan los valores para las velocidades máximas, tanto en sentido horario como antihorario\n\n* V1max = 1900\n* V2max = 1100\n* V0 = 1500');
gettext('**Velocidad en sentido horario**\n\n* Si V1 >= 1900, la velocidad es máxima\n* Si 1900 > V1 > 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**Velocidad en sentido antihorario**\n\n* Si V2 <= 1100, la velocidad es máxima\n* Si 1100 < V2 < 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**dir**: Sentido de giro  \n1: horario / 0: antihorario');
gettext('**Velocidad 0**: Posición para que  \nel servo esté parado');
gettext('Mux 2:1 with logic gates');
gettext('Entrada 1');
gettext('Entrada 0');
gettext('Selección');
gettext('Implementación en Verilog');
gettext('Las puertas están construidas a\npartir de transistores');
gettext('Pincha en algún transistor para\nbajar de nivel');
gettext('Nivel 3: Semiconductores');
gettext('Los transistores se crean a \npartir de uniones entre \nsemiconductores, de tipo P y N\nEstán integrados en los dados de\nsilicio en los circuitos integrados');
gettext('Pincha en el bloque para bajar de nivel');
gettext('Nivel 2: MATERIALES');
gettext('Cristal de silicio');
gettext('Los semiconductores se crean a partir de cristales\nde Silicio (Si) que se dopans con impurezas\npara darle las propiedades de semiconductores');
gettext('Pincha en los bloques para bajar de nivel');
gettext('Átomos de Silicio');
gettext('Nivel 1: ATOMOS');
gettext('Los cristales de silicio se forman a \npartir del enlace covalente entre los\nátomos de silicio. Cada uno de ellos \nestá rodeado por 4 átomos de silicio\nformando un tetraedro');
gettext('<B>Posicion del servo</B>\n\nSe especifica en unidades de 10micro-segundos\nEj. pos = 100 --> Pulso de achura 1ms');
gettext('<B>Generación de una señal PWM para posicionamiento de Servos</B>\nEl periodo es de 20ms\nEl ancho del pulso varía entre 0 - 255 (0 - 2.5ms)');
gettext('Tortuga-2');
gettext('Divisor entre dos');
gettext('Biestable T síncrono, inicializado a 0');
gettext('Biestable T síncrono, inicializado por parametro INI');
gettext('Biestable tipo D con entrada de enable, inicializado al parámetro INI');
gettext('Biestable D con inicialización paramétrica');
gettext('Generar un pulso de reloj al recibir un flanco por la entrada');
gettext('Biestable D inicializado a 0');
gettext('Delay flip-flop');
gettext('Tortuga: Divisor entre 2\n\nImplementado a partir de un\nbiestable T síncrono');
gettext('Hacer que solo responda a los flancos\nde subida de la señal de entrada');
gettext('Emax-ES08A');
gettext('Futaba-3003');
gettext('TowerPro-SG90');
gettext('ServoBit-90');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a las 2 posiciones POS0 y POS1');
gettext('**Posición 1**: Posición del servo cuando  \nse introduce un 1\n\nEl valor por defecto es de 135 grados\n');
gettext('**Posición 0**: Posición del servo cuando  \nse introduce un 0\n\nEl valor por defecto es de 45 grados');
gettext('**Entrada**: posición a donde llevar  \nel servo (posición 0 ó 1)');
gettext('**Servobit paramétrico** para los microservos **EMAX-ES08A** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **580 usec**  \n* Extremo izquierdo **2550 usec**\n');
gettext('ServoBit');
gettext('Servobit-90');
gettext('ServoBit para Futaba 3003. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit paramétrico para Futaba 3003. Controlador de 1 bit para mover el servo a las 2 posiciones P0 y P1');
gettext('**Servobit** para Servos Futaba 3003 o comaptibles\nLas dos posiciones están distanciadas **90 grados**  \n\n* **Posicion 0**: 45 grados  \n* **Posicion 1**: 135 grados  ');
gettext('**Servobit paramétrico** para los microservos **Futaba 3003** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **380 usec**  \n* Extremo izquierdo **2410 usec**\n');
gettext('Servobit');
gettext('Servobit-90');
gettext('ServoBit para micrservo TowerPro-SG90. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('**Servobit paramétrico** para los microservos **TowerPro SG-90** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **500 usec**  \n* Extremo izquierdo **2350 usec**\n');
gettext('Servobit');
gettext('0-Soluciones-Tutorial-19');
gettext('1-Ejemplos');
gettext('2-Ejercicios');
gettext('Sol-19-1');
gettext('**Sensor IR izquierdo**');
gettext('**Sensor IR derecho**');
gettext('**Cuello de Franky**');
gettext('**Tabla de verdad**\n\n| Fila | Sensor Izdo | Sensor Der |  Cuello  | Descripción |\n|------|-------------|------------|----------|-------------|\n|  0   |    0        |     0      |     0    | Mira izda   |\n|  1   |    0        |     1      |     1    | Mira decha  |\n|  2   |    1        |     0      |     0    | Mira izda   |\n|  3   |    1        |     1      |     1    | Mira decha  |');
gettext('0: Izquierda  \n1: Derecha  ');
gettext('**Solución ejercicio 19.1:** (5 Bitpoints) Fraky en modo defensivo\n\nDiseñar un **circuito combinacional**, mediante su **tabla de verdad**, para controlar  \nla posición del cuello de Franky mediante dos **sensores de infrarrojos**:  \nizquierdo y derecho. Cuando ningún sensor esté activado, o sólo lo esté izquierdo,    \nFranky mirará hacia la izquierda. Cuando el sensor derecho está activado, o  \nambos (izquierdo y derecho), Franky mirará hacia la derecha');
gettext('Sol-19-2');
gettext('**Puerta caja fuerte**');
gettext('**Tabla de verdad**\n\n| Fila | i2 | i1 | i0  | Salida |\n|------|----|----|-----|--------|\n|  0   | 0  | 0  | 0   | 0      |\n|  1   | 0  | 0  | 1   | 0      |\n|  2   | 0  | 1  | 0   | 0      |\n|  3   | 0  | 1  | 1   | 1      |\n|  4   | 1  | 0  | 0   | 0      |\n|  5   | 1  | 0  | 1   | 1      |\n|  6   | 1  | 1  | 0   | 0      |\n|  7   | 1  | 1  | 1   | 0      |');
gettext('0: Cerrada  \n1: Abierta  ');
gettext('**Solución ejercicio 19.2:** (5 Bitpoints) Apertura de caja fuerte\n\nDiseñar un **circuito combinacional**, mediante su **tabla de verdad**, para abrir  \nla puerta de una caja fuerte cuando se introducen los códigos correctos. Se usarán  \n3 interruptores externos para introducir la clave. Cuando esta clave sea **101** ó  \n**011** se moverá un servo a la otra posición, simulando la apertura de la caja');
gettext('**Interruptores externos**');
gettext('Sol-19-3');
gettext('**Paridad**');
gettext('0: impar  \n1: par ');
gettext('**Solución ejercicio 19.3:** (5 Bitpoints) Detector de paridad de 4 bits\n\nDiseñar un **circuito combinacional** de **4 bits de entrada** y uno de salida  \ncapaz de detectar si el número de 1's en sus entradas es **par**. En ese caso, se  \nencenderá el LED conectado a su salida. Si el número es impar, se apagará  \nEste tipo de circuitos se llaman **detectores de paridad**, y se usan mucho en  \ncomunicaciones para comprobar la integridad de la información recibida. La  \nentrada **0000** tiene **paridad par** (0 es par)');
gettext('**Tabla de verdad**\n\n| Fila     | i3     | i2     | i1     | i0     | Salida |\n|----------|--------|--------|--------|--------|--------|\n|  **0**   |  **0** | **0**  |  **0** |  **0** | **1**  |\n|  1       |  0     | 0      |  0     |  1     |   0    |\n|  2       |  0     | 0      |  1     |  0     |   0    |\n|  **3**   |  **0** | **0**  |  **1** |  **1** | **1**  |\n|  4       |  0     | 1      |  0     |  0     |   0    |\n|  **5**   |  **0** | **1**  | **0**  | **1**  |  **1** |\n|  **6**   |  **0** | **1**  | **1**  | **0**  | **1**  |\n|  7       |  0     | 1      |  1     |  1     |   0    |\n|  8       |  1     | 0      |  0     |  0     |   0    |\n|  **9**   |  **1** | **0**  |  **0** |  **1** | **1**  |\n| **10**   |  **1** | **0**  | **1**  | **0**  |  **1** |\n| 11       |  1     | 0      |  1     |  1     |   0    |\n| **12**   |  **1** | **1**  |  **0** |  **0** | **1**  |\n| 13       |  1     | 1      |  0     |  1     |   0    |\n| 14       |  1     | 1      |  1     |  0     |   0    |\n| 15       |  **1** | **1**  | **1**  | **1**  |  **1** |\n');
gettext('00-2-Leds-on-cables');
gettext('Encendiendo dos LEDs de la forma que conocemos');
gettext('01-Bus-2bits-LEDs');
gettext('**Dos circuitos equivalentes, para encender 2 LEDs**');
gettext('Usando 2 cables **independientes**');
gettext('Usando un **bus de 2 bits**');
gettext('02-Bus-2bits-2-LEDs');
gettext('**Ejemplo 2**: Encendiendo 4 LEDs con 2 buses de 2 Bits');
gettext('03-Bus-4bits-LEDs');
gettext('Ejemplo de **encender 4 LEDs** usando un **bus de 4 Bits**  \nSolo hay que enviar el valor constante 15 ese bus  \n(15 en binario es 1111, que se corresponde con todos  \nlos bits a 1)');
gettext('04-Bus-8bits-LEDs');
gettext('Ejemplo de **encender 8 LEDs** usando un **bus de 8 Bits**  \nSolo hay que enviar el valor constante 255 por ese bus  \n(255 en binario es 11111111, que se corresponde con todos  \nlos bits a 1)');
gettext('05-Constante-8-bits-1-LEDs');
gettext('Ejemplo para enviar el **valor 129** a los LEDs, y que se enciendan  \nlos que correspondan. Usamos una **constante genérica de 8 bits**  \na la que se le pasa como parámetro el valor 129. Ahora podemos  \n**editar** fácilmente este valor para enviar cualquier otro');
gettext('06-Constante-4-bits-1-LEDs');
gettext('Ejemplo del uso de **constantes genéricas de 4 bits**. Los 8 LEDs de la  \nicezum alhambra se han dividido en **dos bloques de 4 bits**. Cada uno está  \nconectado a su constante por un bus de 4 bits');
gettext('07-Constante-8-bits-bases-LEDs');
gettext('Ejemplo para encender todos los LEDs enviando la constante de **8 bits**  \n**255**, en todas sus bases: **decimal**, **hexadecimal** o **binario**');
gettext('**Binario**');
gettext('**Hexadecimal**');
gettext('**Decimal**');
gettext('08-Constante-2-bits-bases-LEDs');
gettext('Ejemplo de envío de **4 constantes de 2 bits** a los LEDs, en las  \n**diferentes notaciones**. Se envían las constantes 0,1, 2 y 3');
gettext('09-agregadores-separadores-2-bits');
gettext('**Agregador** - **Separador**');
gettext('**Separador** - **Agregador**');
gettext('**Ejemplo de agregadores - separadores de 2 bits**');
gettext('10-agregadores-separadores-4-bits');
gettext('11-agregadores-separadores-4-bits-2');
gettext('**Ejemplo**: Intercambiando los bits de mayor y menor peso en un bus de 4 bits\n\nPor un lado la constante 10 se envía a los LEDs 7,6,5 y 4  \nPor otro lado se intercaambian los bits de mayor peso y menor y se llevan  \na los LEDS 3,2,1 y 0');
gettext('11-agregadores-separadores-8-bits');
gettext('12-mux-2-1-8bits-LEDs');
gettext('**Ejemplo 11: Multiplexor 2-1 de 8 bits**\n\nCircuito que enciende alternativamente los LEDs  \npares e impares, por medio del envío de las  \nconstantes 170 y 85 a través de un multiplexor  \n2 a 1 de 8 bits\n');
gettext('13-mux-4-1-4bits-LEDs');
gettext('**Ejemplo 12: Multiplexor 4 a 1 de 4 bits**\n\nSe reproduce una secuencia de dos estados en los LEDS  \nAl apretar el pulsador la secuencia cambia a otra  ');
gettext('Ejercicio-20-1');
gettext('**Ejercicio 20.1**: (5 Bitpoints). **Secuencia de 4 estados en los LEDs**\n\nDiseñar un circuito digital que muestre por los **8 LEDs** de la Icezum Alhambra  \nla siguiente **secuencia**: 0, 15, 255 y 15, que se repetirá indefinidamente.  \nUtilizar un multiplexor de 4 a 1 de 8 bits\n');
gettext('**Entregar**:\n\n  -1 Pantallazo del circuito (2 Bitpoints)\n  \n  -1 Vídeo del funcionamiento (2 Bitpoints)\n  \n  Enviarlos por redes sociales (Twitter, G+) con mención \n  a @Obijuan_cube. El vídeo puede estar en youtube o directamente en el tuit/post\n  ');
gettext('**GITHUB**:\n\n  1 Bitpoint adicional si lo entregáis por Github (sólo pantallazo, el vídeo\n  no hace falta, para que no ocupe tanto espacio)');
gettext('Ejercicio-20-2');
gettext('**Ejercicio 20.2**: (5 Bitpoints). **Operación AND en bus de 2 bits**\n\nDiseñar un circuito digital que saque por los **LEDs 7** y **6** los pulsadores  \n**SW2** y **SW1**, usando un **bus de 2-bits**. Además, se sacará por el **LED0** el  \nresultado de la **operación AND** entre SW1 y SW2, obteniendo sus valores del  \nbus de 2 bits, mediante un separador');
gettext('Ejercicio-20-3');
gettext('**Ejercicio 20.3**: (5 Bitpoints). **Cifrador de números de 4-bits**\n\nDiseñar un circuito digital que **cifre un número de 4-bits** mediante el **intercambio**   \nde sus **bits centrales** (Bits 1 y 2), dejando el de mayor y menor peso iguales (bit 3 y  \nbit 0). El número se introducirá mediante **4 interruptores externos** que entran en la  \nicezum Alhambra mediante un **bus de 4 bits**. El número sin cifrar se sacará por los  \nLEDs 7,6,5 y 4, y el número cifrado por los LEDs 3,2,1 y 0');
