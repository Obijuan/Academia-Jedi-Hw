// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Bits');
gettext('Puertas');
gettext('Varios');
gettext('0');
gettext('Un bit constante a 0');
gettext('1');
gettext('Un bit constante a 1');
gettext('and');
gettext('Puerta AND');
gettext('not');
gettext('Puerta NOT');
gettext('or');
gettext('Puerta OR');
gettext('Bombeo');
gettext('Motor');
gettext('Mux');
gettext('Retardo');
gettext('Servos');
gettext('Corazon_10Hz');
gettext('Bombear 10 bits por segundo');
gettext('Corazon_1Hz');
gettext('Bombear 1 bit por segundo');
gettext('Corazon_1KHz');
gettext('Bombear 1000 bits por segundo');
gettext('Corazon_2Hz');
gettext('Bombear 2 bits por segundo');
gettext('Corazon_2KHz');
gettext('Bombear 2000 bits por segundo');
gettext('Corazon_3Hz');
gettext('Bombear 3 bits por segundo');
gettext('Corazon_4Hz');
gettext('Bombear 4 bits por segundo');
gettext('Corazon_5Hz');
gettext('Bombear 5 bits por segundo');
gettext('Corazon_7Hz');
gettext('Bombear 7 bits por segundo');
gettext('Corazon_DO4');
gettext('Bombear bits a la frecuencia del DO de la cuarta octava');
gettext('Corazon_MI4');
gettext('Bombear bits a la frecuencia del MI de la cuarta octava');
gettext('Corazon_RE4');
gettext('Bombear bits a la frecuencia del RE de la cuarta octava');
gettext('SM-S4303R');
gettext('MotorBit');
gettext('Controlador para servo de rotacion continua SprintRC SM-S4303R. Con on=1, el motor avanza. Dir=1 sentido agujas reloj/ 0 el contrario');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1');
gettext('Mux-2-1');
gettext('Mux-4-1-flip');
gettext('Multiplexor de 4 a 1. Implementado en verilog');
gettext('Mux-4-1');
gettext('Tortuga-2');
gettext('Divisor entre dos');
gettext('Biestable T síncrono, inicializado a 0');
gettext('Biestable T síncrono, inicializado por parametro INI');
gettext('Biestable tipo D con entrada de enable, inicializado al parámetro INI');
gettext('Biestable D con inicialización paramétrica');
gettext('Multiplexor 2:1 de 1-bit');
gettext('NAND logic gate');
gettext('Transistor');
gettext('Transistor cmos hecho a partir de semiconductores');
gettext('Cristal de Siicio');
gettext('Atomos de silicio');
gettext('Generar un pulso de reloj al recibir un flanco por la entrada');
gettext('Biestable D inicializado a 0');
gettext('Delay flip-flop');
gettext('Tortuga: Divisor entre 2\n\nImplementado a partir de un\nbiestable T síncrono');
gettext('Hacer que solo responda a los flancos\nde subida de la señal de entrada');
gettext('Mux 2:1 with logic gates');
gettext('Entrada 1');
gettext('Entrada 0');
gettext('Selección');
gettext('Implementación en Verilog');
gettext('Las puertas están construidas a\npartir de transistores');
gettext('Pincha en algún transistor para\nbajar de nivel');
gettext('Nivel 3: Semiconductores');
gettext('Los transistores se crean a \npartir de uniones entre \nsemiconductores, de tipo P y N\nEstán integrados en los dados de\nsilicio en los circuitos integrados');
gettext('Pincha en el bloque para bajar de nivel');
gettext('Nivel 2: MATERIALES');
gettext('Cristal de silicio');
gettext('Los semiconductores se crean a partir de cristales\nde Silicio (Si) que se dopans con impurezas\npara darle las propiedades de semiconductores');
gettext('Pincha en los bloques para bajar de nivel');
gettext('Átomos de Silicio');
gettext('Nivel 1: ATOMOS');
gettext('Los cristales de silicio se forman a \npartir del enlace covalente entre los\nátomos de silicio. Cada uno de ellos \nestá rodeado por 4 átomos de silicio\nformando un tetraedro');
gettext('Emax-ES08A');
gettext('Futaba-3003');
gettext('TowerPro-SG90');
gettext('ServoBit-90');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('Valor constante para bus de 8 bits');
gettext('Mux 2:1. Bus de 7 bits. ');
gettext('Mux 2:1. Bus de 4 bits. ');
gettext('Agregador de 4 cables a bus de 4bits');
gettext('Separador de bus de 4bits en 4 cables (1 + 1 + 1 + 1)');
gettext('Separador de bus de 8bits en 2 (4 + 4)');
gettext('Agregador de 2 buses de 4 a bus de 8bits');
gettext('Controlador PWM para posicionar servos de 20ms. Las unidades de pos son de 10usec');
gettext('Posición 0');
gettext('Posición 1');
gettext('<B>Posicion del servo</B>\n\nSe especifica en unidades de 10micro-segundos\nEj. pos = 100 --> Pulso de achura 1ms');
gettext('<B>Generación de una señal PWM para posicionamiento de Servos</B>\nEl periodo es de 20ms\nEl ancho del pulso varía entre 0 - 255 (0 - 2.5ms)');
gettext('Servobit-90');
gettext('ServoBit para Futaba 3003. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('Servobit-90');
gettext('ServoBit para micrservo TowerPro-SG90. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('<B>Servobit</B> para microservos TowerPro SG-90 o compatibles\nLas dos posiciones están distanciadas 90 grados\n\n* Posicion 0: 45 grados\n* Posicion 1: 135 grados');
gettext('0-Soluciones-Tutorial-16');
gettext('1-Ejemplos');
gettext('2-Ejercicios');
gettext('Sol-16-1');
gettext('**Solución ejercicio 16.1:**\n\nCircuito de Alarma. Mientras que el sensor IR está detectando un objeto en su campo  \nsonará una alarma en la que dos tonos de 1 y 2Khz se alternan a la frecuencia de 2Hz');
gettext('Sol-16-2');
gettext('**Solución ejercicio 16.2:**\n\nDiseñar un circuito digital que suba una **barrera** cuando el **sensor de IR** detecta la  \npresencia de un coche. Se cierra cuando no se detecta nada. El circuito todavía no \ntemporiza nada, ni almacena información. Simplemente sube o baja la barrera en función\ndel estado del sensor IR');
gettext('Sol-16-3');
gettext('**Rueda izquierda**');
gettext('**Rueda Derecha**');
gettext('**Sensor izquierdo**');
gettext('**Sensor derecho**');
gettext('**Solución ejercicio 16.3:**\n\nHacer un circuito digital para que el robot icebot siga a un objeto. Utilizará dos  \nsensores IR colocados en su parte delantera. Siempre que el icebot esté en movimiento  \nse activará una sirena acústina y otra luminosa. La sirena es la misma que la del \nejercicio 1. La luminosa está formada por dos LEDs que parpadean anternativamente a  \nla misma frecuecia que la acústica (2Hz)');
gettext('**Sirena acústica**');
gettext('**Activación sirenas**  \nSirena en todos los casos  \nmenos cuando está detenido');
gettext('**Sirena Luminosa**');
gettext('1-OR-pulsadores');
gettext('**Ejemplo 1: puerta OR con pulsadores**  \n\nLas entradas son dos pulsadores  \nCada pulsador está conectado a un LED para ver su estado  \nEl resultado de la OR se muestra por otro LED');
gettext('2-OR-boton-IR');
gettext('**Ejemplo 2: Alarma manual o por presencia**  \n\nLa sirena se hace sonar bien apretando el pulsador, o bien  \nporque se ha detectado la presencia de un intruso');
gettext('3-Cerradura-doble-clave');
gettext('**Ejemplo 3: Cerradura que se hable con dos claves**\n\nLa cerradura tiene 2 claves. Bien 111 o bien 000  \nLas dos abren la caja y el servo cambia de posición');
gettext('Clave 111 detectada');
gettext('Clave 000 detectada');
gettext('LEDs testigo');
gettext('Ejercicio-17-1');
gettext('**Ejercicio 17.1**: (3 Bitpoints). **Barrera automática y manual**\n\nDiseñar el circuito digital para controlar una **barrera de acceso** que se levantará  \n**automáticamente** cuando detecte la presencia de un coche, y se bajará cuando no lo haya.  \nAdemás, tiene un **modo manual** para poder subirla mediante un **interruptor**.  \nLa barrera sólo baja si no hay coche detectado y no está activada manualmente\n');
gettext('**Entregar**:\n\n  -1 Pantallazo del circuito (1 Bitpoints)\n  \n  -1 Vídeo del funcionamiento (1 Bitpoints)\n  \n  Enviarlos por redes sociales (Twitter, G+) con mención \n  a @Obijuan_cube. El vídeo puede estar en youtube o directamente en el tuit/post\n  ');
gettext('**GITHUB**:\n\n  1 Bitpoint adicional si lo entregáis por Github (sólo pantallazo, el vídeo\n  no hace falta, para que no ocupe tanto espacio)');
gettext('Ejercicio-17-2');
gettext('**Ejercicio 17.2**: (5 Bitpoints). **Caja fuerte con dos claves de apertura**\n\nDiseñar un circuito digital para que se abra una **caja fuerte** cuando se   \nintroduce el código **101** ó el **010** en tres interruptores externos. Al  \nabrirse se moverá un servo a una posición, y cuando está cerrada se moverá a  \nla contraria\n');
gettext('**Entregar**:\n\n  -1 Pantallazo del circuito (2 Bitpoints)\n  \n  -1 Vídeo del funcionamiento (2 Bitpoints)\n  \n  Enviarlos por redes sociales (Twitter, G+) con mención \n  a @Obijuan_cube. El vídeo puede estar en youtube o directamente en el tuit/post\n  ');
gettext('Ejercicio-17-3');
gettext('**Ejercicio 17.3**: (7 Bitpoints). **Franky con disparo automático y manual**\n\nDiseñar un circuito digital para que franky funcione en modo \"defensa\". Estará  \nmirando de lado a lado con un periodo de **4 segundos** (2 segundos en cada lado).  \nEn uno de los lados disparará automáticamente una **ráfaga** por sus ojos, que   \nparpadearán a una frecuencia de **10Hz**. Además, durante el disparo, sonarán **pitidos  \nde 1Khz**, con una **cadenacia de 10Hz** (pi-pi-pi-pi...). Adicionalmente se colocará  \nun **pulsador** para **disparo manual**. Al pulsarlo realizará los mismos disparos  \ncomentados anteriormente (señal luminosa en los ojos y pitidos de 1Khz con  \ncadencia de 10Hz)\n');
gettext('**Entregar**:\n\n  -1 Pantallazo del circuito (3 Bitpoints)\n  \n  -1 Vídeo del funcionamiento (3 Bitpoints)\n  \n  Enviarlos por redes sociales (Twitter, G+) con mención \n  a @Obijuan_cube. El vídeo puede estar en youtube o directamente en el tuit/post\n  ');
